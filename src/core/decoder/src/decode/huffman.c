/* Copyright (c) V-Nova International Limited 2022. All rights reserved. */
#include "decode/huffman.h"

#include "common/memory.h"
#include "context.h"

#include <stdlib.h>

static const int32_t kMaxSymbols = 256;

/*------------------------------------------------------------------------------*/

static int32_t bitWidth(uint32_t x, uint8_t useOldCodeLength)
{
    /* Table is generated by the following, with a special case for index 0.
           out = ceil(log2(length + 1)) */
    static const int32_t kTable[2][32] = {
        {
            1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        },
        {
            1, 1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
            5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        },
    };

    /* Old code lengths indexed the "table" with max_length - min_length + 1
     * New code lengths indexes the table with max_length - min_length. */
    const uint32_t entry = x + useOldCodeLength;

    if ((entry > 31) || (useOldCodeLength > 1)) {
        /* This should be impossible as lengths are 5-bits maximum. */
        return 0;
    }

    return kTable[useOldCodeLength][entry];
}

static int32_t tableAssign(Context_t* ctx, HuffmanDecodeState_t* state, HuffmanEntry_t* order, int32_t maxIdx)
{
    int32_t currLength = (int32_t)state->maxCodeLength;
    uint32_t currCode = 0;

    /*
     * For each length group of symbols, generate non-prefix codes of the
     * correct length
     */
    for (int32_t i = (int32_t)state->maxCodeLength; i >= (int32_t)state->minCodeLength; i--) {
        for (int32_t j = 0; j < maxIdx; j++) {
            HuffmanTable_t* table = &state->table;

            if (order[j].bits == i) {
                if (i < currLength) {
                    currCode >>= (currLength - i);
                    currLength = i;
                }

                /* If the code word is > 8 bits, we need to create subtables */
                while (order[j].bits > 8) {
                    /* @todo(bob): Fix this, needless mask on uint8_t, was the mask meant to be on the calculation? */
                    uint8_t idx = (uint8_t)(currCode >> (order[j].bits - 8));
                    idx &= 0xff;

                    /* If a subtable already exists, continue */
                    if (table->code[idx].next != NULL) {
                        order[j].bits -= table->code[idx].bits;
                        table = table->code[idx].next;
                        continue;
                    }

                    /* create a new table */
                    table->code[idx].bits = 8;
                    table->code[idx].symbol = 0;
                    table->code[idx].next = VN_CALLOC_T(ctx->memory, HuffmanTable_t);

                    if (table->code[idx].next == NULL) {
                        VN_ERROR(ctx->log, "Unable to allocate next table\n");
                        return -1;
                    }

                    /* Move the current table to the new one */
                    table = table->code[idx].next;

                    if (order[j].bits - 8 >= 8) {
                        table->idxBits = 8;
                    } else {
                        table->idxBits = order[j].bits - 8;
                    }

                    /* Allocate the codes array */
                    const size_t codeArraySize = (size_t)1 << table->idxBits;
                    table->code = VN_CALLOC_T_ARR(ctx->memory, HuffmanEntry_t, codeArraySize);

                    if (table->code == NULL) {
                        VN_ERROR(ctx->log, "Unable to allocate next codes\n");
                        return -1;
                    }

                    order[j].bits -= 8;
                }

                /* Add the remaining bits of the code word to the current table */
                uint8_t idx = (uint8_t)(currCode << (table->idxBits - order[j].bits));
                idx &= (1 << table->idxBits) - 1;

                for (int32_t k = 0; k < 1 << (table->idxBits - order[j].bits); k++) {
                    table->code[idx].bits = order[j].bits;
                    table->code[idx].symbol = order[j].symbol;
                    table->code[idx].next = NULL;
                    idx++;
                }

                order[j].bits = 0;
                currCode++;
            }
        }
    }

    return 0;
}

static void tableErase(Context_t* ctx, HuffmanTable_t* table, int32_t dealloc)
{
    const int32_t max = 1 << table->idxBits;

    if (table->code != NULL) {
        for (int32_t i = 0; i < max; i++) {
            if (table->code[i].next != NULL) {
                tableErase(ctx, table->code[i].next, 1);
            }

            table->code[i].next = NULL;
        }
    }

    if (dealloc != 0) {
        if (table->code != NULL) {
            VN_FREE(ctx->memory, table->code);
        }

        VN_FREE(ctx->memory, table);
    }
}

static int tableEntrySymbolOrder(const void* left, const void* right)
{
    const HuffmanEntry_t* leftEntry = (const HuffmanEntry_t*)left;
    const HuffmanEntry_t* rightEntry = (const HuffmanEntry_t*)right;
    return (int)leftEntry->symbol - rightEntry->symbol;
}

/*------------------------------------------------------------------------------*/

int32_t huffmanInitialise(Context_t* ctx, HuffmanDecodeState_t* state, BitStream_t* stream)
{
    int32_t res = 0;

    if (state == NULL || stream == NULL) {
        VN_ERROR(ctx->log, "huffman: state or stream NULL\n");
        return -1;
    }

    state->table.idxBits = 8;
    state->table.code = state->codes;
    memorySet(state->codes, 0, sizeof(state->codes));

    int32_t bits = 0;
    VN_CHECK(bitstreamReadBits(stream, 5, &bits));
    state->minCodeLength = (uint32_t)bits;

    VN_CHECK(bitstreamReadBits(stream, 5, &bits));
    state->maxCodeLength = (uint32_t)bits;

    if (state->maxCodeLength < state->minCodeLength) {
        VN_ERROR(ctx->log, "huffman: code lengths are invalid, max length [%u] is less than min length [%u]\n",
                 state->minCodeLength, state->maxCodeLength);
        return -1;
    }

    if (state->minCodeLength == 31 && state->maxCodeLength == 31) {
        /* "Special" case - empty table*/
        return 0;
    }

    if (state->minCodeLength == 0 && state->maxCodeLength == 0) {
        /* another "Special" case */
        /* only one code */
        VN_CHECK(bitstreamReadBits(stream, 8, &bits));
        state->singleSymbol = (uint8_t)bits;
        return 0;
    }

    const int32_t lengthBits =
        bitWidth(state->maxCodeLength - state->minCodeLength, ctx->useOldCodeLengths);

    if (lengthBits < 1) {
        VN_ERROR(ctx->log, "huffman: code lengths are invalid, resulted in incorrect bit-width max length [%u], min length [%u]\n",
                 state->maxCodeLength, state->minCodeLength);
        return -1;
    }

    uint8_t bit = 0;
    VN_CHECK(bitstreamReadBit(stream, &bit));

    int32_t orderIdx = 0;
    HuffmanEntry_t order[256];

    if (bit) {
        for (int32_t i = 0; i < kMaxSymbols; ++i) {
            /* Symbol present flag */
            VN_CHECK(bitstreamReadBit(stream, &bit));
            if (bit) {
                int32_t codeLength = 0;
                VN_CHECK(bitstreamReadBits(stream, (uint8_t)lengthBits, &codeLength));
                order[orderIdx].symbol = (uint8_t)i;
                order[orderIdx].bits = (uint8_t)(codeLength + state->minCodeLength);
                orderIdx++;
            }
        }
    } else {
        /* Read symbol-count */
        int32_t symbolCount = 0;
        VN_CHECK(bitstreamReadBits(stream, 5, &symbolCount));

        if (symbolCount <= 0) {
            return -1;
        }

        for (int32_t i = 0; i < symbolCount; ++i) {
            int32_t symbol = 0;
            int32_t codeLength = 0;
            VN_CHECK(bitstreamReadBits(stream, 8, &symbol));
            VN_CHECK(bitstreamReadBits(stream, (uint8_t)lengthBits, &codeLength));

            order[orderIdx].symbol = (uint8_t)symbol;
            order[orderIdx].bits = (uint8_t)(codeLength + state->minCodeLength);
            orderIdx++;
        }
    }

    /* Different encoders may signal symbols in different undefined orders. It is
     * however assumed that symbols are assigned codes in symbol ascending order
     * within their code length groups.
     *
     * The production encoder signals in ascending (ungrouped) symbol order.
     * The LTM encoder signals in grouped descending order.
     *
     * Neither are wrong as it is not specified in the standard the absolute order
     * that symbols must be signaled in the bit-stream - it in fact does not specify
     * the order that symbols are assigned codes where their lengths are the same,
     * but in such case the LTM implementation becomes the reference.
     *
     * To mitigate this let's ensure that whatever the order that symbols are signaled
     * in they are sorted based upon what tableAssign expects - in this case it
     * expects ascending symbol order. */
    qsort(order, orderIdx, sizeof(HuffmanEntry_t), tableEntrySymbolOrder);

    if (tableAssign(ctx, state, order, orderIdx) != 0) {
        huffmanRelease(ctx, state);
        return -1;
    }

    return 0;
}

void huffmanRelease(Context_t* ctx, HuffmanDecodeState_t* state)
{
    tableErase(ctx, &state->table, 0);
}

int32_t huffmanDecode(Context_t* ctx, HuffmanDecodeState_t* state, HuffmanStream_t* stream, uint8_t* symbol)
{
    int32_t res = 0;

    HuffmanTable_t* table = &state->table;

    if (state == NULL || stream == NULL || symbol == NULL) {
        VN_ERROR(ctx->log, "state, stream or symbol NULL\n");
        return -1;
    }

    if (state->minCodeLength + state->maxCodeLength == 0) {
        *symbol = state->singleSymbol;
        return 0;
    }

    if (stream->byte < 0) {
        /* Read maximum of 8 bits */
        const uint8_t readCount =
            (uint8_t)minU32(8, (uint32_t)bitstreamGetRemainingBits(&stream->stream));

        int32_t bitsIn = 0;
        VN_CHECK(bitstreamReadBits(&stream->stream, readCount, &bitsIn));
        stream->byte = (int16_t)(bitsIn << (8 - readCount));
    }

    /* Consume bits until we hit the last subtable */
    uint8_t idx = (uint8_t)(stream->byte >> (8 - table->idxBits));

    while (table->code[idx].next != NULL) {
        const uint8_t bits = table->code[idx].bits;

        stream->byte = (int16_t)(stream->byte << bits);

        uint8_t readCount = bits;
        if (readCount > bitstreamGetRemainingBits(&stream->stream)) {
            readCount = (uint8_t)bitstreamGetRemainingBits(&stream->stream);
        }

        if (readCount) {
            int32_t bitsIn = 0;
            VN_CHECK(bitstreamReadBits(&stream->stream, (uint8_t)readCount, &bitsIn));
            stream->byte = (int16_t)(stream->byte | (bitsIn << (bits - readCount)));
        }

        stream->byte &= 0xFF;

        table = table->code[idx].next;
        idx = (uint8_t)(stream->byte >> (8 - table->idxBits));
    }

    /* Decode symbol */
    *symbol = table->code[idx].symbol;
    const uint8_t bits = table->code[idx].bits;

    if (bits == 0) {
        /* unknown code */
        VN_ERROR(ctx->log, "unknown huffman code\n");
        return -1;
    }

    stream->byte = (int16_t)(stream->byte << bits);
    uint8_t readCount = bits;
    if (readCount > bitstreamGetRemainingBits(&stream->stream)) {
        readCount = (uint8_t)bitstreamGetRemainingBits(&stream->stream);
    }

    if (readCount) {
        int32_t bitsIn = 0;
        VN_CHECK(bitstreamReadBits(&stream->stream, (uint8_t)readCount, &bitsIn));
        stream->byte = (int16_t)(stream->byte | (bitsIn << (bits - readCount)));
    }

    stream->byte &= 0xFF;

    /* Track number of consumed bits on stream. */
    stream->bitsRead += bits;

    return 0;
}

/*------------------------------------------------------------------------------*/
